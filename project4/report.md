# <center> 中山大学计算机学院人工智能本科生高级搜索实验报告
> <center>（2022学年春季学期）
------
<font size=2>课程名称：Artificial Intelligence</font>

<div class="center">
## 一.实验题目
**使用模拟退火算法和遗传算法解决旅行商(TSP)问题**


## 二.实验内容

### 1.算法原理：

- ### 模拟退火(**Simulated Annealing**):

  - 模拟退火算法类似于物理退火的过程，因此由此得名为“模拟”。物理退火先在一个高温状态下，然后逐渐退火，徐徐冷却，最终达到物理基态。
  - 而模拟退火在开始时对初始数据进行算法随机搜索，其过程中有很大概率会接受劣解，之后接受劣解概率变小直至为零，最后找到最优解。
  - 模拟退火是一种贪心算法，但是额外在搜索过程引入随机因素。因为模拟退火算法会**以一定的概率**接受一个比当前解要差的解，因此**有可能**会跳出局部的最优解，达到全局的最优解。而这个**一定概率跳出局部最优解的过程是算法的核心**。

- ### 遗传算法(Genetic Algorithms):

  - 遗传算法则是模拟生物自然进化的过程得出最优解的方法。自然界中一个种群的第一代之后经过自然选择，剩下存活的物种进行繁衍，正常过程繁衍中也有可能出现后代变异的情况，而这些后代们又会形成新的种群，如此往复。
  - 而遗传算法则是模拟预设初始种群的大小，之后经过适应度函数进行筛选，之后进行数据交换，交换后的个体加入种群中。
  - 遗传算法中的数据交叉会以**一定概率发生变异**，产生规律不同于之前的数据，因此**有可能**会跳出局部的最优解，达到全局的最优解。

### 2.相关思路以及流程图：
- ### **相关思路** ：

    #### 旅行商问题 ( TSP , Traveling Salesman Problem ) ：

    - 有N个城市，旅行商要从其中某个城市出发，走过所有城市并且仅走过一次，最后再回到出发的城市，由此求最短的路线。旅行商问题属于NP完全问题，精确的解决TSP只能通过穷举所有的路径组合，但是时间复杂度是O(N!) ，这将耗费大量时间。

    #### 模拟退火(SA)：

    1. **先预设一条随机的遍历路径，并计算其路径长度。**
    
    2. **进入退火循环，在一个温度中进行3000次循环(状态稳定)后进入下一个温度，直到温度到达最低。**

    3. **在循环中按照三等分的概率对路径进行节点交换，产生新的路径：**
    
       - **两个节点直接互换交换位置。**
       - **将两个节点间的全部节点插入到另一个节点之后。**
       - **将两个节点间的顺序逆转。**
       
    4. **计算新产生路径的长度，若新路径长度优于当前最优路径，则状态稳定，进入下一温度，并替换最优路径，否则按照模拟退火的接受概率接受新解。**其中接受概率p如下：

    $$
    P = exp( -(新解的长度-当前最优的长度)/当前温度 )
    $$
    
    5. **在温度到达最低温反复重复3、4步。**
    
    - #### 流程图：
    
      ><img src="img/SAmindmap.png">
    
    #### 遗传算法(GA)：
    
    1. **预设一个大小为200的种群，并且随机产生其中物种的路径。之后计算所有物种的路径长度，得到适应度函数**
    
    $$
    f = 1/当前路径长度
    $$
    
       2.**进入物种选择循环，循环5000次(遗传5000代)。**
    1. **根据轮盘赌选择或锦标赛选择，选择出新的优秀种群**
    2. **对优秀种群进行数据交叉，即繁衍操作**
    3. **对繁衍种群按照一定概率使用变异操作**
    4. **反复重复3、4、5步，让种群繁衍到设定代数。**
    
    - #### 流程图：
    
    
    ><img src="img/GAmindmap.png">
### 3.关键代码展示：

#### 一、基本设置：

```python
def mk_cord() : #输入数据
    node_num = int(input())
    cord = []
    for i in range(node_num) :
        get_node = input().split()
        cord.append(get_node[1:])  
    return node_num,cord
def get_adjm(node_num,cord) :    #创建邻接矩阵
    adm = list(0.0 for index in range(node_num**2))
    for i in range(node_num) :
        for j in range(i,node_num) :    #计算欧氏距离
            adm[i*node_num + j] = adm[j*node_num + i] = ((float(cord[i][0])-float(cord[j][0]))**2 + (float(cord[i][1])-float(cord[j][1]))**2)**0.5
    return adm    
def print_matrix(node_num,adm) :    #打印邻接矩阵
    for i in range(node_num **2) :
        if (i+1)%node_num == 0 :
            print(adm[i])
        else :
            print(adm[i],end='  ')
def draw_road(cord,bestroad) :  #画出城市路线图
    xp = []
    yp = []
    for i in bestroad :     #存好每个点的数据
        xp.append(float(cord[i][0]))
        yp.append(float(cord[i][1]))
    plt.plot(xp,yp,'g-s')   #标每个点的数据
    x = [xp[0],xp[-1]]
    y = [yp[0],yp[-1]]
    plt.plot(x,y,"*b:",markersize=10)   #起点终点特别标注
    plt.show()
```

- 程序运行首先输入城市节点数，然后按照顺序形成矩阵。之后通过计算欧氏距离得到邻接矩阵。

#### 二、路径改变函数：

- **倒转两个点之间的所有点顺序**

```python
def reverse_segment(p,node_num) :#倒转两个点之间的所有点顺序
    new = random.sample(p, 2)   #随机取两个点
    new.sort()              #排序
    temp = p[0:new[0]]      #截取到选中点前    
    temp_re = list(reversed(p[new[0]:new[1]]))  #逆转顺序
    temp.extend(temp_re)    
    temp.extend(p[new[1]:node_num])
    return temp
```

- **将两条路径某一点后的所有节点交换**

```python
def exchange_node(dad,mom,node_num) :#将两条路径某一点后的所有节点交换
    pos = random.randint(0, node_num)#随机取点
    son1 = dad[0:pos]           #两天路径slice
    son2 = mom[0:pos]
    son1.extend(mom[pos:node_num])#交换随机点后的所有节点
    son2.extend(dad[pos:node_num])
    same1 = []  #查重
    same2 = []
    for i in range(pos,node_num):   #找到重复进行交换
        for j in range(pos):
            if son1[i] == son1[j]:
                same1.append(j)
            if son2[i] == son2[j]:
                same2.append(j)
    for i in range(len(same1)):
        son1[same1[i]], son2[same2[i]] = son2[same2[i]], son1[same1[i]]
    return son1,son2 
```

- **将两个节点中间所有节点插入第三个节点后**

```python
def insert_segment(p,node_num) :#将两个节点中间所有节点插入第三个节点后
    new = random.sample(p, 3)   #随机取三个点
    new.sort(reverse=True)      #排序
    temp = p[new[2]:new[1]].copy()      #交换
    p[new[2]:new[0]+new[2]-new[1]+1] = p[new[1]:new[0]+1].copy()
    p[new[0]+new[2]-new[1]+1:new[0]+1] = temp   #插入
    return p
```

#### 三、模拟退火(SA)：

```python
def waySA() :
    node_num ,cord= mk_cord()    #结点数以及结点矩阵
    adm = get_adjm(node_num,cord)
    #print_matrix(node_num,adm)   #按照矩阵打印列表
    res = []
    newroad = list(range(node_num)) #产生新解的路径，也是初始化
    random.shuffle(newroad)         #随机打乱
    curroad = newroad.copy()        #局部最优解
    bestroad = newroad.copy()       #全局最优解
    bestdist = 9000000          #全局最小距离
    curdist = 9000000           #局部最小距离
    
    speed = 0.98                #退火速度
    t_min = 0.0000001           #结束温度
    t_cur = 10000               #初温
    while t_cur > t_min :       #循环
        for i in range(3000) :  #达到稳定前进行循环(产生局部最优解前)
            random_num = random.random()    #3等分概率，随机数决定使用哪种方式改变路径
            if 0.6 > random_num > 0.3 :     #直接交换两个点的位置
                new = random.sample(newroad, 2)
                newroad[new[0]],newroad[new[1]] = newroad[new[1]],newroad[new[0]]
            elif random_num >= 0.6 :        #将两个点间的所有节点加入第三个点后
                newroad = insert_segment(newroad, node_num)
            else :                  #逆转两个点间的所有节点
                newroad = reverse_segment(newroad, node_num)
            newdist = 0             #新解的路径长度
            for i in range(node_num) :  #计算新解路径长度
                if i!=node_num-1 :
                    newdist += adm[newroad[i]*node_num+newroad[i+1]]
                else :
                    newdist += adm[newroad[0]*node_num+newroad[-1]]
            if newdist < curdist :      #如果新解优于当前最优解则替换
                curdist = newdist
                curroad = newroad.copy()
                if newdist <bestdist :  #如果新解优于全局最优解则替换
                    bestdist = newdist
                    bestroad = newroad.copy()
            else :  #否则按照一定概率接受新解
                if random.random() < math.exp(-(newdist-curdist)/t_cur) :
                    curdist = newdist
                    curroad = newroad.copy()
                else :
                    newroad = curroad.copy()
        t_cur = t_cur*speed #退火温度降低
        res.append(bestdist)
        print(t_cur)
    print(bestdist)
    print(bestroad)
    
    draw_road(cord, bestroad)   #画出退火曲线
    plt.plot(res)
    plt.xlabel('temperature')
    plt.ylabel('best_result')
    plt.show()
```

- 可见模拟退火的主体在于退火阶段的**二重循环**，代码基本遵循上数**算法原理**的步骤。
- 其中为了增加产生**新解的可行性**，使用三种不同方式对路径进行改变。

#### 四、遗传算法(GA)：

```python
def wayGA(node_num,cord) :
    # node_num ,cord= mk_cord()    #结点数以及结点矩阵
    adm = get_adjm(node_num,cord)
    races = []      #种群
    species = 50000 #物种
    num = 200   #群落
    individual = 0 #个体
    res = []
    ancestor = list(range(node_num)) #祖先
    cnt = 0
    while cnt != num :   #初始化种群
        random.shuffle(ancestor)    #随机改变
        temp = ancestor.copy()
        if temp not in races :
            races.append(temp)
            cnt = cnt +1
    ind_list = []
    ind_dis = []
    while individual < species :    #开始进行遗传
        individual += 1     #遗传代数++
        f = []
        #获取适应度函数
        for j in races :    
            newdist = 0
            for i in range(node_num) :#计算种群中每条路径的长度
                if i!=node_num-1 :
                    newdist += adm[j[i]*node_num+j[i+1]]
                else :
                    newdist += adm[j[0]*node_num+j[-1]]
            f.append(1/newdist)#压入
        sig = sum(f)
        #选择
        p = []
        new_races = []  #新种群
        #轮转赌选择
        for i in f :        #利用适应度函数计算出判断标准p
            p.append(i/sig)
        temp = {}       
        for i in range(len(p)): #先取出种群中最好的前百分之20条路径
            temp[i] = p[i]
        index_of_max = [k[0] for k in sorted(temp.items(),key=lambda e:e[1])[::-1][:int(num*0.2)]]
        
        for i in index_of_max :     #压入新种群
            new_races.append(races[i])
        temp_index = list(range(num))
        choose = random.choices(temp_index,weights=p,k=int(0.8*num))    #随机从剩下的路径出成员组成新种群
        for i in choose :
            new_races.append(races[i])
        #开始遗传
        for i in range(int(num/2)) :
            j = i + int(num/2) - 1
            if random.random() < 0.7 :#交叉
                mom = new_races[i]
                dad = new_races[j]
                son1,son2 = exchange_node(dad, mom, node_num)
                if random.random() <0.1 :#变异
                    son1 = reverse_segment(son1, node_num)
                    son2 = reverse_segment(son2, node_num)
                new_races[i] = son1
                new_races[j] = son2
        races = new_races
        dist = []   #种群距离
        for j in races :   #为了绘制图像临时计算每一代最小路径长度
            newdist = 0
            for i in range(node_num) :
                if i!=node_num-1 :
                    newdist += adm[j[i]*node_num+j[i+1]]
                else :
                    newdist += adm[j[0]*node_num+j[-1]]
            dist.append(newdist)
        print(individual)
        bestdist = min(dist)
        res.append(bestdist)
        best_index = dist.index(bestdist)
        bestroad = races[best_index]  
    print('The shortest distance : ',bestdist)
    totald.append(bestdist)
    print('The shortest road : ',bestroad)
    draw_road(cord, bestroad)
    plt.plot(res)
    plt.show()    
```

- 使用随机数生成随机的种群，计算种群的每条路径的长度，由此得出适应度f。
- 首先取出种群中适应度最大的前百分之20的路径，加入新种群。
- 使用轮盘赌选择，选出剩下的新种群成员。
- 对新种群进行下一代繁殖，直到遗传代数达到上限。

### 4.代码改动：
以上遗传算法实现代码得到的结果与最优解的误差在10%左右，为减少误差，进行改进：

- #### 种群成员选择改成：锦标赛选择

  ##### 锦标赛选择：在种群中随机选择 2条路径(放回或不放回)进行比较，适应值更好的路径被选择作为生成新种群的父体。反复执行该过程，直到新种群路径数量达到预定的规模。

- #### 变异的方式扩展：

  - 原本只采用**倒转两个点之间的所有点顺序**的方法
  - 添加**随机打乱路径**的方法
  - 添加**将两个节点中间所有节点插入第三个节点后**方法

改进后代码如下：

``` 
def wayGA(node_num,cord) :
    # node_num ,cord= mk_cord()    #结点数以及结点矩阵
    adm = get_adjm(node_num,cord)
    races = []      #种群
    species = 50000 #物种
    num = 200   #群落
    individual = 0 #个体
    res = []
    ancestor = list(range(node_num)) #祖先
    cnt = 0
    while cnt != num :   #初始化种群
        random.shuffle(ancestor)    #随机改变
        temp = ancestor.copy()
        if temp not in races :
            races.append(temp)
            cnt = cnt +1
    ind_list = []
    ind_dis = []
    while individual < species :    #开始进行遗传
        individual += 1     #遗传代数++
        f = []
        #获取适应度函数
        for j in races :    
            newdist = 0
            for i in range(node_num) :#计算种群中每条路径的长度
                if i!=node_num-1 :
                    newdist += adm[j[i]*node_num+j[i+1]]
                else :
                    newdist += adm[j[0]*node_num+j[-1]]
            f.append(1/newdist)#压入
        sig = sum(f)
        #选择
        p = []
        new_races = []  #新种群
        #轮转赌选择
        for i in f :        #利用适应度函数计算出判断标准p
            p.append(i/sig)
        temp = {}       
        for i in range(len(p)): #先取出种群中最好的前百分之20条路径
            temp[i] = p[i]
        index_of_max = [k[0] for k in sorted(temp.items(),key=lambda e:e[1])[::-1][:int(num*0.2)]]
        
        for i in index_of_max :     #压入新种群
            new_races.append(races[i])
        temp_index = list(range(num))
        choose = random.choices(temp_index,weights=p,k=int(0.8*num))    #随机从剩下的路径出成员组成新种群
        for i in choose :
            new_races.append(races[i])
        #开始遗传
        for i in range(int(num/2)) :
            j = i + int(num/2) - 1
            if random.random() < 0.7 :#交叉
                mom = new_races[i]
                dad = new_races[j]
                son1,son2 = exchange_node(dad, mom, node_num)
                if random.random() <0.1 :#变异
                    if random.random() < 0.8 :#变异形式1，翻转两个结点间的内容
                        son1 = reverse_segment(son1, node_num)
                        son2 = reverse_segment(son2, node_num)
                    elif random.random() > 0.6:#变异形式2，将两个结点间内容插入第三个结点后
                        son1 = insert_segment(son1, node_num)
                        son2 = insert_segment(son2, node_num)
                    else :#变异形式3，随机打乱结点
                        random.shuffle(son1)
                        random.shuffle(son2)
                new_races[i] = son1
                new_races[j] = son2
        races = new_races
        dist = []   #种群距离
        for j in races :   
            newdist = 0
            for i in range(node_num) :
                if i!=node_num-1 :
                    newdist += adm[j[i]*node_num+j[i+1]]
                else :
                    newdist += adm[j[0]*node_num+j[-1]]
            dist.append(newdist)
        print(individual)
        bestdist = min(dist)
        res.append(bestdist)
        best_index = dist.index(bestdist)
        bestroad = races[best_index]  
    print('The shortest distance : ',bestdist)
    totald.append(bestdist)
    print('The shortest road : ',bestroad)
    draw_road(cord, bestroad)
    plt.plot(res)
    plt.show()    
```

#### 交叉的方式扩展：

- 原本采用单点交叉，将两条路径的某点后的所有节点交换

- 更新**两点交叉**，将两条路径任意两点间的所有节点进行交换

- ```python
  def exchange_double_node(dad,mom,node_num) :#将两条路径随机两个点后的所有节点交换
      pos = random.sample(dad, 2)#随机取点
      pos.sort()
      son1 = dad[0:pos[0]]           #两条路径slice
      son2 = mom[0:pos[0]]
      t1 = dad[pos[0]:pos[1]]
      t2 = mom[pos[0]:pos[1]]
      son1.extend(mom[pos[0]:pos[1]])#交换随机点后的所有节点
      son2.extend(dad[pos[0]:pos[1]])
      son1.extend(dad[pos[1]:node_num])
      son2.extend(mom[pos[1]:node_num])
      same1 = []  #查重
      same2 = []
      for i in range(pos[0],pos[1]):   #找到重复进行交换
          for j in range(0,pos[0]):
              if son1[i] == son1[j]:
                  same1.append(j)
              if son2[i] == son2[j]:
                  same2.append(j)
      for i in range(pos[0],pos[1]):  	 #因为分成三段，所以要再找一次，找到重复进行交换
          for j in range(pos[1],node_num):
              if son1[i] == son1[j]:
                  same1.append(j)
              if son2[i] == son2[j]:
                  same2.append(j)
      for i in range(len(same1)):
          son1[same1[i]], son2[same2[i]] = son2[same2[i]], son1[same1[i]]
      return son1,son2
  ```

  但事实上，以上改动对结果并未产生明显的优化，如此结论由下述**实验结果**分析得出。

## 三.实验结果及分析
#### 实验结果

#### 注：1.因为此次实验需要调用matplotlib库中的plot进行图像绘制，但是整个库的大小非常大，打包成exe有324m大小，远远超过实验课提交文件限制，因此不再额外设置界面并且打包成exe。

#### 		2.因为python直接打开生成的exe会将复制粘贴输入的换行符进行格式化，会出现以下情况：

><img src="img/error1.png">

#### 从而导致数据输入错误，因此在test文件夹中设置format.rtf，将欲复制粘贴的数据先进行格式化后，在贴入程序，从而得到以下正确的结果。

- ##### 输入界面：
    ><img src="img/r1.png">

- 运行结果：

  ><img src="img/r2.png">

    - ##### 以上左侧数字是当前的温度，倒二行是最短路径的长度，最后一行是最短路径。右侧图像为最小路径图。
  
  ><img src="img/r3.png">

  - ##### 该图为退火曲线图。

- ### 以上是简单展示，接下来是ch130和qa194的结果展示：

  - #### ch130：

    #### 模拟退火
    
    ##### 达到最优路径6110.722。当然，这是运气好的情况，正常结果范围在6110~6300之间浮动，详情请查看总结分析。
    
    ><img src="img/ch130sa.png">
    ><img src="img/ch130sa2.png">
    ><img src="img/ch130sa3.png">
    
    - 模拟退火最短路径图与退火温度图。
    
    - ##### 最后一图放大模拟退火曲线。
    
    #### 遗传算法
    
    ##### 遗传算法的误差较大、且结果更加随机，因此放出两个结果截图。
    
    **结果为6378.878**
    
    ><img src="img/ch130ga.png">
    ><img src="img/ch130ga2.png">
    
    - **左侧为遗传代数**
    
    ##### 结果为6857.874
    
    ><img src="img/ch130ga3.png">
    ><img src="img/ch130ga4.png">
  
  - #### qa194：
  
    #### 模拟退火
  
    ><img src="img/qa194sa.png">
    ><img src="img/qa194sa2.png">
  
    #### 遗传算法
  
    ><img src="img/qa194ga.png">
  
    ><img src="img/qa194ga2.png">

#### *注：因为城市节点大于100，与最优路径有误差，更多相关内容会在接下来的**总结分析**中进行讲述。

#### 总结分析

<div class="center">
##### 数据:**ch130**


#### **算法：SA**

### 1.不同的结束温度

| 初始温度/结束温度/退火速度 | 最短路径长度 |运行时间|
|:-----:|:---------:|:----:|
| **10000/1e-7/0.98** |6344.876\|6290.356\|6297.253\|6174.803\|6387.749|80\|81\|81\|80\|81 |
|10000/1e-3/0.98|6213.574\|6198.733\|6203.875\|6228.471\|6235.949|50\|51\|44\|47\|45|
| 10000/0.1/0.98 |6352.218\|6298.770\|6234.727\|6410.029\|6350.683 | 39\|31\|38\|40\|44 |

- 由此可知，模拟退火的结束温度对**运行时间以及结果误差都有影响，其中温度越小误差越小、运行时间也越长。**因为这代表着循环的扩展。

### 2.不同的初始温度

| 初始温度/结束温度/退火速度 |                    最短路径长度                    |      运行时间       |
| :------------------------: | :------------------------------------------------: | :-----------------: |
|       10000/0.1/0.98       |  6352.218\|6298.770\|6234.727\|6410.029\|6350.683  | 39\|37\|38\|40\|44  |
|       7000/0.1/0.98        |  6353.203\|6417.737\|6284.206\|6297.231\|6319.347  | 31\|35\|36\|33\|36  |
|       5000/0.1/0.98        | 6249.840\|6245.084\|6338.953\|6258.962\|6302.848\| | 34\|35\|35\|34\|395 |
|       3000/0.1/0.98        | 6328.174\|6299.893\|6227.777\|6411.137\| 6323.262  | 32\|33\|35\|33\|34  |

- 由结果可知，不同的初始温度影响并不大。

### 3.不同的退火速度

#### 对照组请参考上一组数据

| 初始温度/结束温度/退火速度 |                    最短路径长度                     |        运行时间         |
| :------------------------: | :-------------------------------------------------: | :---------------------: |
|    **10000/1e-7/0.99**     |  6166.254\|6294.811\|6110.772\|6205.322\|6312.461   | 163\|164\|163\|163\|162 |
|      10000/0.001/0.99      |  6295.467\|6190.734\|6238.265\|6219.163\|6263.620   |   96\|97\|96\|98\|97    |
|       10000/0.1/0.99       |  6234.372\|6203.381\|6267.055\|6305.294\|6173.751   |   68\|68\|68\|69\|69    |
|       5000/0.1/0.99        |  6233.490\|6257.816\|6157.798\|6320.064\|6209.654   |   64\|64\|64\|64\|64    |
|      5000/0.001/0.99       |  6236.154\|6270.259\|6217.673\|6247.399\|6257.220   |   92\|92\|92\|92\|92    |
|       5000/1e-7/0.99       | 6345.072\|6316.346\|6169.414\|6222.949\|6285.557161 | 147\|146\|146\|147\|147 |

- 跟之前的案例对比，可以得到**0.99的退火速度的误差更小，但是运行时间是0.98的2倍**

综上我们选择**初温10000、结束温度1e-7、退火速度0.99**作为最佳配置。

其中ch130的**最小误差**为(6116.254-6110)/6110 = **0.1023%**，**最大误差**为(6312.461-6110)/6110 = **3.3136%**

#### **算法：GA**:(在第4步前，交叉概率为0.7，变异为0.1)

### **1.不同变异方式**(轮盘赌选择、两点交叉)：

**综合对比**

|            变异方式            |                     最短路径长度                      |        运行时间         |
| :----------------------------: | :---------------------------------------------------: | :---------------------: |
| **倒转两个点之间的所有点顺序** |   6398.242\|6571.216\|6720.905\|6493.123\|6239.178    | 103\|106\|107\|103\|102 |
|    两点间所有点插入第三个点    |   8236.466\|8685.548\|9154.129\|9716.650\|7969.356    | 105\|104\|103\|103\|102 |
|          随机打乱路径          | 21115.996\|23931.187\|21732.531\|22680.895\|22646.779 | 107\|106\|108\|106\|106 |

**三种方式混合(比例顺序为倒转、插入、随机)**

| 变异方式比例  |                    最短路径长度                    |          运行时间          |
| :-----------: | :------------------------------------------------: | :------------------------: |
| **0.8/0.6/-** |  6429.264\|6991.237\|6597.463\|6743.359\|7203.126  |  103\|104\|106\|106\|106   |
|  0.3/0.3/0.3  | 6845.635\|7447.422\|7337.445\| 7014.265\| 6934.368 |  119\|117\|118\|119\|123   |
|  0.8/0.2/0.1  |  6879.360\|7060.159\|7335.156\|7146.853\|7183.813  |  107\|107\|108\|108\| 107  |
|  0.6/0.2/0.2  | 6828.713\|7052.870\| 7023.357\| 6944.563\|7175.588 | 108\|108\| 108\| 107\| 107 |
|  0.7/0.2/0.1  | 7241.170\| 7384.343\|7178.270\|6864.622\|7181.187  | 107\| 109\|108\| 107\|108  |

- **其中第一行案例为意外发现**：意思是，**倒转概率为0.8，在执行倒转操作后，还有0.6概率执行插入操作**，这样的跑出的结果误差意外的小。
- **还额外测试了许多样例，但是距离最优路径误差超过10%许多，便不再展示**
- 由此可见，上述改动中添加不同的变异方式**反而是一种累赘**，得出结论**仅使用倒转方式的变异最有效**。

### 2.不同的选择方式：

- **轮转赌0.8** : 代表轮盘赌选择中选取80%的个体作为新种群
- 因为上一步得出**倒转变异**最有效,所以使用倒转变异。
- 为了达到**控制变量**，设置交叉方式均为**两点交叉**。

##### 两点交叉，倒转变异

|   组合    |                   最短路径长度                   |        运行时间         |
| :-------: | :----------------------------------------------: | :---------------------: |
| 轮盘赌0.7 | 6795.423\|6926.813\|7114.964\|6829.955\|7049.690 | 104\|107\|119\|108\|115 |
| 轮盘赌0.8 | 6398.242\|6571.216\|6720.905\|6493.123\|6239.178 | 103\|106\|107\|103\|102 |
| 轮盘赌0.9 | 6600.350\|6888.576\|6909.522\|6926.114\|6987.904 | 107\|107\|108\|108\|107 |
|  锦标赛   | 6648.162\|6909.868\|6894.926\|6722.479\|7372.939 | 143\|143\|142\|141\|140 |

- 由此可见**轮盘赌方法**中**选择比为0.8能出现误差最小的解**,0.8和0.9的**差距只在2%**左右 。
- 可以看到选择方式的不同对**结果的误差影响不大**，但是**锦标赛选择的运行时间要远长于轮盘赌选择**。

### **3.不同的交叉方式：**

- **轮转赌0.8**:代表轮盘赌选择中选取80%的个体作为新种群
- 因为上一部得出**倒转变异**最有效,所以使用倒转变异.

|        组合        |                   最短路径长度                    |          运行时间          |
| :----------------: | :-----------------------------------------------: | :------------------------: |
| 单点交叉+轮盘赌0.8 | 6912.542\|6729.536\|7013.221\|7055.259\|6847.352  |  108\|109\|109\|108\|107   |
| 两点交叉+轮盘赌0.8 | 6398.242\|6571.216\|6720.905\|6493.123\|6939.178  |  103\|106\|107\|103\|102   |
| 单点交叉+轮盘赌0.9 | 6624.623\|7030.714\|6895.953\|6663.336\|6760.511  | 103\|104\| 103\| 104\| 104 |
| 两点交叉+轮盘赌09  | 7058.182\|7018.661\|7355.768\|7373.432\| 7039.067 |  105\|105\|106\|108\| 110  |
|  单点交叉+锦标赛   | 6985.813\|7007.740\|6592.208\|6726.418\|6958.951  |  140\|144\|142\|144\|145   |
|  两点交叉+锦标赛   | 6648.162\|6909.868\|6894.926\|6722.479\|7372.939  |  143\|143\|142\|141\|140   |

- 可以看到**交叉方式**的不同对**结果的误差影响不大**，但是**锦标赛选择的运行时间要远长于轮盘赌选择**。

### 4.不同的交叉概率和变异概率：

- 以上步骤我们得出当前最优配置**两点交叉/单点交叉、轮盘赌0.8、单个倒转变异**，以下寻找最适配的**超参数**。

|        组合         |                      最短路径长度                      |          运行时间          |
| :-----------------: | :----------------------------------------------------: | :------------------------: |
|   0.7交叉+0.4变异   |  7101.690\| 7441.303\|7088.917\| 6962.104\| 7128.491   |  103\|102\|103\|104\|102   |
|   0.7交叉+0.3变异   | 37498.172\|37629.365\| 37657.465\|36192.111\|35283.637 |  106\|107\|107\|107\|107   |
|   0.7交叉+0.2变异   |    6791.695\|6884.505\|6803.716\|6643.084\|7030.258    | 104\|104\| 103\| 104\| 104 |
|   0.7交叉+0.1变异   |    6912.542\|6729.536\|7013.221\|7055.259\|6847.352    |  105\|105\|106\|108\| 110  |
|   0.8交叉+0.1变异   |   7019.777\| 6862.134\|6651.798\|6945.454\|7038.881    |  112\|113\|112\|114\|113   |
|   0.8交叉+0.2变异   |  6780.327\| 7007.023\| 6689.266\|6937.071\| 6600.772   |  113\|113\|112\|113\|113   |
|   09交叉+0.1变异    | 37239.199\| 37451.469\|33938.441\|33547.348\|33863.072 |  128\|127\|126\|127\|127   |
|   0.9交叉+0.2变异   |   7388.465\|6998.024\|6887.794\| 7180.343\|7098.982    |  121\|120\|121\|121\|121   |
|   0.6交叉+0.1变异   |   7126.311\| 7009.263\|7038.354\|7155.188\|6624.906    |     94\|95\|94\|95\|94     |
|   0.6交叉+0.2变异   |   6640.002\| 6711.816\|6906.960\|6922.473\| 6586.926   |     93\|93\|93\|94\|94     |
|   0.5交叉+0.1变异   |   6735.134\| 6860.101\|7022.533\|6974.314\| 7208.376   |     84\|83\|83\|83\|83     |
| **0.5交叉+0.2变异** |   6865.068\| 6535.860\|6466.722\|6652.509\|6525.012    |     84\|83\|83\|84\|84     |
|   0.5交叉+0.3变异   |   6860.542\| 6894.672\|6658.367\|6684.726\| 6745.954   |     83\|83\|83\|84\|83     |
|   0.5交叉+0.4变异   |    6910.880\|6593.172\|6787.286\|6731.751\|6984.867    |     81\|81\|80\|80\|80     |

- 以上可以看出变异的概率对**运行时间几乎无影响**，对**误差的影响也在2%~3%左右**。
- **交叉的概率越小运行时间越少**，误差的影响微乎其微。**其中最稳定、误差最小为0.5交叉+0.2变异**。

### 5.不同的种群大小和遗传代数：

- #### 此前的种群大小均为200，遗传代数均为5000。模拟退火的初温和迭代次数对结果影响很大，为了这些参数探究是否对遗传算法有同样的影响。

- 以上步骤我们得出当前最优配置**两点交叉/单点交叉、轮盘赌0.8、单个倒转变异，0.5交叉+0.2变异**。

|        组合        |                    最短路径长度                     |         运行时间         |
| :----------------: | :-------------------------------------------------: | :----------------------: |
|   5000代+200种群   |  6865.068\|6535.860\|6466.722\|6652.509\|6525.012   |    84\|83\|83\|84\|84    |
|   5000代+400种群   |  6685.097\|7060.818\|6695.828\|6708.948\|6534.020   | 158\|161\|158\|157\|160  |
| **5000代+500种群** | 6487.572\| 6598.700\|6465.106\| 6363.412\| 6761.847 | 197\|198\|196\|198\|197  |
|   5000代+600种群   |  6662.396\|6892.868\|6632.069\|6766.164\|6598.119   | 239\|238\|239\|239\|239  |
|   5000代+800种群   |   6865.674\|6371.280\|6833.002\|6581.96\|6785.364   | 315\|316\|316\|316\|316  |
|   8000代+200种群   |  6577.776\|6805.009\|6992.118\|6440.058\|6732.583   | 132\|131\|129\|130\|129  |
|   8000代+400种群   |  6846.263\|6430.166\|6672.544\|6852.864\|6925.988   | 251\|251\|248\|251\|252  |
| **8000代+800种群** | 6607.815\| 6634.837\|6399.130\| 6378.946\|6781.073  | 541\|540\|540\|544\|538  |
|  10000代+200种群   | 6602.541\| 6748.960\|7067.215\| 6640.718\| 6874.245 | 159\|158\|158\|159\|161  |
|  10000代+400种群   | 6858.815\|6656.186\|6510.856\| 6650.032\| 6429.955  | 285\|284\|285\|283\|284  |
|   6000代+600种群   |  6614.587\|6802.233\|7086.773\|6717.859\| 6791.801  | 199\|197\|200\|197\|199  |
|   4000代+400种群   | 6646.017\|6656.527\| 6911.576\|6480.423\| 6591.668  | 129\|128\|130\| 129\|128 |

- 可以见得种群的大小对**结果直接误差影响不大,但是产生的结果会更加稳定的集中在一个区间内，但会增加运行时间**。也许**不同的遗传代数有对应的最佳种群大小**。
- **目前得出：遗传代数为种群的10倍是，结果最稳定，误差会尽可能小**

- 以上可以得出，按照当前配置，最优的组合为**5000代+500种群和8000代+800种群**。
- 8000代+800种群的误差似乎更优一点点，但是运行时间过长，因此我们之后选择**5000代+500种群**。

</div>

以上可以得出**当前遗传算法**误差最小、运行速度最快的**配置**为**5000代+500种群,0.5交叉+0.2变异，轮盘赌选择、单个倒转变异**。

其中ch130**最优配置**下**最小误差**为(6363.412-6110)/6110 = **4.1474%**,**最大误差**为(6761.847-6110)/6110 = **10.6685%**

#### *上述结果可见ch130样例中，模拟退火的误差和运行时间各方面都优于遗传算法。

#### * 由上述给出的最佳配置给出下述新的测试测数据的结果，与模拟退火进行进一步的对比。    

|   数据/方式    |                     最短路径长度                      |        运行时间         |
| :------------: | :---------------------------------------------------: | :---------------------: |
|   burma14/SA   |        30.878\|30.878\|30.878\|30.878\|30.878         |   35\|35\|35\|35\|35    |
| **burma14/GA** |        30.878\|30.878\|30.878\|30.878\|30.878         |   16\|16\|16\|16\|16    |
|    dj38/SA     |   6659.431\|6659.431\| 6659.431\|6659.431\|6659.431   |   59\|59\|59\|59\|59    |
|  **dj38/GA**   |   6659.431\|6659.431\|6659.431\|6659.431\|6659.431    |   41\|41\|41\|41\|41    |
|  **qa194/SA**  |  9667.076\|9739.007\| 9727.805\|9703.766\| 9774.235   | 212\|211\|212\|211\|211 |
|    qa194/GA    | 10157.819\|10648.601\|10146.694\|10514.003\|10251.638 | 370\|371\|372\|371\|370 |

可以看到，当**搜索样例较小**时，两个算法都可以得出最优解，但是**遗传算法的速度要快于模拟退火**。但是当样例一多，**遗传算法的误差、结果的区间、随机性将大于模拟退火**。

#### **结论：**

- 模拟退火算法随着搜索范围 T ( 温度 )的降低，**最优解会越来越稳定**。只要**初始温度**设置得足够大，最后得到最优路径的误差就会越小，其中的代价是**时间**。
- 模拟退火对于应对**要求不同精确度的结果时，最优的初始温度、退火速度、结束温度都会有不同的组合。**
- 遗传算法的一些参数参数如**交配概率、变异概率**等的选择直接影响算法的优劣，细微的数据差能引发最优路径的误差波动，因此欲调试出**最合适的参数组合非常困难**。
- 遗传算法的**初始种群以及遗传代数**对结果也有影响，且当种群的**最优路径误差越小**时，算法收敛**越慢**。
- 遗传算法随机性太大，**曾经有一次在ch130案例中的最佳配置下跑出6275的数据，但是本人因为过于兴奋忘记截图记录。而之后的改动也再没低于6400**。

#### 综上，个人认为模拟退火的便利性以及可靠性更优于遗传算法。当然当tsp的城市**节点数量较小**时，遗传算法的速度更快，但当节点数多时，遗传算法结果的随机性太大，数值浮动在5%~15%之间，获得误差小的结果有一定的运气成分且概率很低，因此个人认为**遗传算法不如模拟退火**。

## 四.参考资料
>  [(68条消息) 模拟退火的一些个人见解_numberer的博客-CSDN博客_ms退火模拟](https://blog.csdn.net/numberer/article/details/79996753)

>  [白话讲解遗传算法 (qq.com)](https://mp.weixin.qq.com/s/VKU7UQ2iYzGfnbk41ltdBA)