# <center> 中山大学计算机学院人工智能本科生启发式搜索实验报告
> <center>（2022学年春季学期）
------
<font size=2>课程名称：Artificial Intelligence</font>
<div class="center">
## 一.实验题目
**使用A星或IDA星算法解决15-Puzzle问题，启发式函数可以自己选取，最好多尝试几种不同的启发式函数**


## 二.实验内容

### 1.算法原理：
两个算法的估价函数都是 ：  f = g + h 
> 经过选择好的启发式函数算出初始节点到i节点的代价g,x节点到目标节点的最小估计代价h，g和h的和为f

**其中最为估计值的h更接近实际值h*是最佳状态**
> <img src="img/o1.png">
- A星算法 ：
    
    >设置open集和close集，从起点开始。首先将起点放入open，通过启发式函数算出open中最小估计的f，将拥有最小f的节点加入close、将其从open中删去，并在open中加入其的子相邻节点。.如果新的相邻节点已经在open中，则更新它们的g值。循环上述操作直到找到目标节点。
- 双向A星算法：
    
    >原理同A星，两个A星同时进行，一个以起始节点为开始，一个以目标节点为开始，将循环结束条件改成两个open表出现相同节点。
- IDA星算法 ：
    > IDA星也是迭代加深的A星算法，因为是迭代加深通过深度优先搜索进行的，所以比起A星不需要维护open和close集，空间复杂度自然更小。
    
    >首要要设置一个可访问深度阈值d，算法一般使用递归实现，每一步递归都进行深度优先搜索，在其中一步对应节点的f大于d时，对已经访问的节点集进行剪枝。直到找到某个节点为目标节点为止。

### 2.相关思路以及流程图：
- **相关思路** ：本次实现采用的是A星算法。而后为减少算法时间复杂度采用双向A星算法。启发式函数采用曼哈顿距离。之后为了尽量满足h<=h'的条件，对曼哈顿距离所求得的估计代价进行简单的变换。
- **流程图**：
    基本A星算法：
    ><img src="img/fc1.png">
    双向A星算法：
    ><img src="img/fc2.png">

### 3.关键代码展示：
#### As1.0 ：基础A星实现：
>①按照基本A*的流程图实现As1.0中的代码，使用node类型存储节点信息：f，g，h，前驱结点，前驱结点的移动以及节点状态。其中node类型中有getf()函数，用于计算当前节点距离目标节点的曼哈顿距离。
><img src="img/cd1-0-1.png">

>②其中mov函数为扩展当前节点，即将'0'号进行上、下、左、右的移动，前驱结点的移动是为了**防止重复扩展而陷入死循环**，如：当前节点的前驱结点是由前驱结点的前驱结点向“上”移动，则当前节点不能向下移动，否则**当前节点**会和**其前驱结点的前驱结点**重复。
><img src="img/cd1-0-2.png">

>③设置comp函数检查**扩展节点**是否已经存在于open/close中，若存在则更换代价更小的节点
><img src="img/cd1-0-3.png">

>④Astar函数为A星算法的具体实现，在open表f值最小节点的扩展之一为目标节点前，需要一直循环，
<img src="img/cd1-0-4.png">

>⑤按照Astar函数的实现，路径存在于close集中，便实现findr函数进行寻找
<img src="img/cd1-0-5.png">

剩余的代码为变量定义以及输出，便不再赘述。

### 4.代码优化：
#### 注 ：每个版本开头都有该版本相关说明，如下：
<img src="img/o2.png">
#### As1.1 ：双向A星实现
因对As1.0进行样例测试时，**样例1、2以及样例4均以最短路径结果成功通过**，但是**样例3**经过一个多小时都**未能出结果**，经过查看课程群里同学讨论结果，采用双向A星算法，减少扩展节点数量和深度，以减少代码时间复杂度以及空间复杂度。
>同时新设置open、close表，并且同时进行扩展，使代码长度*2，循环结束条件改成两个open表出现相同元素。
<img src="img/cd1-1-1.png">

其余函数基本不变便不再赘述。
#### As1.2 ：节点状态压缩、修改启发函数 
对As1.1进行测试时发现，实验结果除了**扩展节点数减少、运行时间略微减少**基本不变，甚至**样例2的结果不是最短路径**，而**样例3仍长时间未响应**，经过查看课程群里同学讨论结果，尝试对节点的状态进行压缩，并修改启发函数。 
>使用元组存储节点状态，并将open集改成优先队列heapq，取代原本列表的sort函数
<img src="img/cd1-2-1.png">

**经过多次测试发现在曼哈顿距离的解乘上4/3更加会使得h更加接近h*，因此之后的版本启发函数全部沿用该版本的**
><img src="img/cd1-2-2.png">

#### **As2_0 ：实验最终版本 **
对As1.2进行测试时发现，经过改变曼哈顿距离，**样例1、2、4双向A星的结果又回到最短路径**，但是样例3经过40分钟仍未出结果，经过调试发现，**问题出在算法循环层数过多**。即**扩展节点的mov函数使用的双重循环以及寻找open表中相同元素的双重循环大大减缓了运行效率。**
因此做出如下修改： 
- 1.改进扩展节点的mov函数，使节点扩展从2层循环嵌套改进为单层循环
><img src="img/cd2-0-2.png">
- 2.As1.2双向A*在open集寻找相同元素需要双重循环，对于更多步骤较大的案例，时间复杂度过高。使用dopp、opp两个set()简化判断条件，以达到不需要循环即可解答，时间复杂度从O(n^2)->O(1)。
><img src="img/cd2-0-3.png">
- 3.为了进一步减少循环次数，close集的存储结构改成set()，以减少comp函数的使用。
><img src="img/cd2-0-1.png">

#### As2.1 ：进一步压缩节点状态 
虽然As2_0已经是最终版本，本人对于同学们在课程群讨论的 **"压缩状态，不进入磁盘"** 可以加快速度的观点表示怀疑，但秉着**实践是检验真理的唯一标准**的教条，便以自己的理解尝试，将所有节点信息放在一个tuple中，在扩展状态时可以**减少**生成node节点而**额外消耗的内存空间**。
><img src="img/cd2-1-1.png">

#### As2.2 ：更改启发函数的算法
As2.1的实验结果并不理想，甚至不如As2_0。发现原版启发式函数的计算使用了双重循环，于是在As2.2中将其精简为单层for循环
><img src="img/cd2-2-1.png">

## 三.实验结果
#### 注 ：以下截图结果是电脑未充电情况下运行，表格中的结果为电脑充电时的结果。经过测试，电脑充电比未充电的运行时间快3倍。
- **程序运行截图：**
  输入：
  ><img src="img/r1.png">
  因篇幅有限便不一一显示。
  输出：
  ><img src="img/r2.png">
  ><img src="img/r3.png">
  ><img src="img/r4.png">
  ><img src="img/r5.png">
  ><img src="img/r6.png">
  ><img src="img/r7.png">
  图中图形化界面中，点击search进行运算，play进行结果可视化展示，⏸使展示暂停，🔄为重新展示，⏭为快进到下一个节点展示，⏮为回退到上一个节点展示
  **图形化详情请查看15puzzle.mp4**

#### 总结分析
<div class="center">

数据：1 2 4 8 5 7 11 10 13 15 0 3 14 6 9 12 
| 版本 | 扩展节点数 |花费时间| 步数 |
|:-----:|:---------:|:----:|:---: |
| As1.0 |293|0.21000409126281738 |22
|As1.1|26|0.03271031379699707| 26
| As2.1 |27 |  0.008064508438110352 | 23
| As2.2 |140 | 0.006014585494995117 | 22   
| As2_0 |21 | 0.0030002593994140625 | 22

数据：5 1 3 4 2 7 8 12 9 6 11 15 0 13 10 14
| 版本 | 扩展节点数 |花费时间| 步数 |
|:-----:|:---------:|:----:|:---: |
| As1.0 |20 | 0.0037271976470947266| 15
|As1.1|8| 0.007912635803222656|15
| As2.1 |16 |0.005001544952392578| 15
| As2.2 |16 |  0.0023211659393310547 |15    
| As2_0 |10|  0.0010001659393310547 | 15

数据：14 10 6 0 4 9 1 8 2 3 5 11 12 13 7 15
| 版本 | 扩展节点数 |花费时间| 步数 |
|:-----:|:---------:|:----:|:---: |
| As1.0 |未知| 一小时以上 | 未出结果
|As1.1|未知| 40分钟以上 | 未出结果
| As2.1 |114031 | 189.5064361095428 | 524
| As2.2 |10226 | 1.4168481826782227 | 58   
| As2_0 |41984|  22.73944592475891 |  58

数据：6 10 3 15 14 8 7 11 5 1 0 2 13 12 9 4
| 版本 | 扩展节点数 |花费时间| 步数 |
|:-----:|:---------:|:----:|:---: |
| As1.0 |未知| 一小时以上 | 未出结果
|As1.1|未知| 40分钟以上 | 未出结果
| As2.1 |43447 | 37.186847448349 | 478
| As2.2 |59795 |38.61324071884155 | 62   
| As2_0 |13164 | 3.5100998878479004 | 52

数据：11 3 1 7 4 6 8 2 15 9 10 13 14 12 5 0
| 版本 | 扩展节点数 |花费时间| 步数 |
|:-----:|:---------:|:----:|:---: |
| As2.1 |86597 |  117.1708242893219 | 356
| As2.2 |未知| 15分钟以上 | 未出结果    
| As2_0 |21221 | 7.246742486953735 | 64

数据：0 5 15 14 7 9 6 13 1 2 12 10 8 11 4 3
| 版本 | 扩展节点数 |花费时间| 步数 |
|:-----:|:---------:|:----:|:---: |
| As2.1 |122617 | 223.30980730056763 | 518
| As2.2 |未知| 20分钟以上 | 未出结果    
| As2_0 |63525 | 50.62020540237427 | 70

</div>    

**结论：**
1.从前两个表格可以看出双向A星算法的时间复杂度和空间复杂度较A星算法要少的多,但路线不一定是最短路径(As1.1)。若对启发式函数进行优化则会提高最短路径出现的概率(As2.1/As2.2/As2_0)。

2.As1.0和As1.1跑不出步数多于50的样例，对比As2之后版本的算法，说明算法的时间复杂度需要控制在O(n^2)以内，否则节点的扩展会越来越慢。

3.As2_0和As2.1、As2.2的综合表现可以得出，**As2_0是最成功的版本**，As2.1因为元组的不变性，在改变值进行list转换是容易出错，导致扩展无用节点以及走无效路径。As2.2因为涉及到字符str和int的转换以及运算，也许在计算时会出错，导致部分结果出错。

4.经过多次测试，因样例过多便不再展示，得出15puzzle的启发函数所求得的估计值**h乘上4/3最接近实际代价h星**。
## 四.参考资料
>  本次实验参考了课堂发布的ppt：**Lab 3 启发式搜索.ppt**以及**班群里同学们与TA的讨论结果**